// Generated by CoffeeScript 1.4.0
var auth, delay, get, get_raw, log, q, root, user;

log = function() {
  return typeof console !== "undefined" && console !== null ? typeof console.log === "function" ? console.log.apply(console, arguments) : void 0 : void 0;
};

delay = function(f, t) {
  return setTimeout(t, f);
};

q = function(query) {
  return document.querySelector(query);
};

Node.prototype.q = function(query) {
  return this.querySelector(query);
};

Object.getOwnPropertyNames(Array.prototype).forEach(function(prop) {
  if (Array.prototype[prop] != null) {
    if ((typeof Array.prototype[prop]) === "function") {
      return NodeList.prototype[prop] = Array.prototype[prop];
    }
  }
});

user = "jiyinyiyong";

if (location.hash.match(/#\w+/)) {
  user = location.hash.match(/#(\w+)/)[1];
}

auth = "client_id=...&client_secret=...";

auth = "";

root = function(username, reponame) {
  return "https://api.github.com/repos/" + username + "/" + reponame + "/contents/";
};

get = function(path, callback) {
  var req, the_path;
  req = new XMLHttpRequest;
  log("get:", path);
  if (path.indexOf("?") >= 0) {
    the_path = path + "&" + auth;
    req.open("get", the_path);
  } else {
    the_path = path + "?" + auth;
    req.open("get", the_path);
  }
  req.onload = function(res) {
    var text;
    text = res.target.response;
    return callback(JSON.parse(text));
  };
  return req.send();
};

get_raw = function(path, callback) {
  var req, the_path;
  req = new XMLHttpRequest;
  if (path.indexOf("?") >= 0) {
    the_path = path + "&" + auth;
    log("the_path", the_path);
    req.open("get", the_path);
  } else {
    the_path = path + "?" + auth;
    log("the_path", the_path);
    req.open("get", the_path);
  }
  req.setRequestHeader("Accept", "application/vnd.github.VERSION.raw");
  req.onload = function(res) {
    var text;
    text = res.target.response;
    return callback(text);
  };
  return req.send();
};

window.onload = function() {
  var el, get_repo, get_user, match, pop, render_file, render_list, string;
  el = {
    list: q("#list"),
    user: q("#user"),
    page: q("#page")
  };
  marked.setOptions({
    breaks: true
  });
  get_user = function(username) {
    return get("https://api.github.com/users/" + username, function(data) {
      el.user.q(".profile").innerHTML = '';
      return el.user.q(".profile").appendChild(lilyturf.dom(function() {
        return this.div({}, this.img({
          src: data.avatar_url
        }), this.div({
          "class": "username"
        }, this.text(data.name)), this.div({
          "class": "location"
        }, this.text(data.location)));
      }));
    });
  };
  get_user(user);
  get_repo = function(username) {
    var repo_url;
    repo_url = "https://api.github.com/users/" + username + "/repos";
    repo_url += "?type=owner&sort=updated";
    return get(repo_url, function(data) {
      return data.forEach(function(repo) {
        var elem;
        elem = lilyturf.dom(function() {
          return this.div({
            "class": "repo"
          }, this.p({
            "class": "repo-name"
          }, this.text(repo.name)), this.p({
            "class": "description"
          }, this.text(repo.description)));
        });
        el.user.q(".repos").appendChild(elem);
        return elem.onclick = function() {
          var contents;
          el.list.q(".repo").innerText = repo.name;
          el.list.q(".path").innerText = "";
          contents = repo.contents_url.replace("{+path}", "");
          get(contents, render_list);
          return el.list.q(".repo").onclick = function() {
            return get(contents, render_list);
          };
        };
      });
    });
  };
  get_repo(user);
  render_list = function(list) {
    el.list.q(".list").innerHTML = "";
    return list.forEach(function(file) {
      var elem;
      elem = lilyturf.dom(function() {
        return this.div({
          "class": file.type
        }, this.text(file.name));
      });
      el.list.q(".list").appendChild(elem);
      return elem.onclick = function() {
        var repo, state;
        log("click:", file);
        el.list.q(".path").innerText = file.path;
        if (file.type === "dir") {
          get(file.url, render_list);
        } else {
          get_raw(file.url, function(text) {
            return render_file(text, file.path);
          });
        }
        repo = file.url.match(/repos\/[\w\d-]+\/([\w\d-]+)\//)[1];
        state = {
          user: user,
          repo: repo,
          path: file.path
        };
        return history.pushState(state, file.path, "#" + user + "/" + repo + "/" + file.path);
      };
    });
  };
  render_file = function(text, path) {
    page.innerHTML = "";
    if (path.match(/\w+\.(md)$/)) {
      return page.innerHTML = marked(text);
    } else if (path.match(/\w+\.(png)|(jpg)|(jpeg)|(gif)$/i)) {
      return page.innerText = "Images are not available";
    } else {
      return page.appendChild(lilyturf.dom(function() {
        return this.pre({}, this.code({}, this.text(text)));
      }));
    }
  };
  window.onpopstate = function(pop) {
    var start, state;
    log('onpopstate', pop.state);
    state = pop.state;
    if (state != null) {
      get_user(state.user);
      start = root(state.user, state.repo);
      get(start, render_list);
      return get_raw(start + state.path, function(text) {
        return render_file(text, state.path);
      });
    }
  };
  if (location.hash != null) {
    string = location.hash.slice(1);
    match = string.match(/^([\w\d-]+)\/([\w\d-]+)\/(\S+)$/).slice(1);
    pop = {
      state: {
        user: match[0],
        repo: match[1],
        path: match[2]
      }
    };
    log(match, pop);
    return onpopstate(pop);
  }
};
